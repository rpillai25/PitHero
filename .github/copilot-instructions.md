# GitHub Copilot Instructions – Pit Hero Event-Driven Version

- The project is written in C# using **FNA + Nez** (not MonoGame).
- Run dotnet test PitHero.Tests/ for unit tests after code changes are complete and solution builds
- /// <summary> Comment all methods with a very concise summary
- Game runs as a **horizontal strip** at bottom of screen (borderless, always-on-top, click-through optional)
- Virtual resolution: 1920×360
- ECS pattern using **Nez framework**:
  - All components inherit from `Nez.Component`
  - Use `Nez.RenderableComponent` or custom extensions for rendering
  - Hero has a collider whose PhysicsLayer is GameConfig.PhysicsHeroWorldLayer.  The PhysicsLayer determines which colliders collide with this
  - Hero collider currently collides with TileMap (GameConfig.PhysicsTileMapLayer)
- Architecture constraints:
  - **Single Hero**: There is only ever 1 active hero at a time (no multiple heroes)
  - **Single Pit**: There is only ever 1 active pit with configured size (not random size)
  - **Individual Components**: Each component class should be in its own file
  - **MSTest**: Use standard MSTest framework for testing, not custom test runners
  - **Nez Boilerplate**: Keep Program.cs as standard Nez boilerplate (FNA setup).  This should not be modified unless absolutely required when there is no other workaround.
- Rendering/UI:
  - Live strip renders current `WorldState`
  - TileMap Layers
    - `Base`: The lowest layer
    - `Collision`: The collision layer	
	- `FogOfWar`: The FogOfWar layer (4 surrounding FogOfWar tiles cleared whenever Hero lands on tile underneath)
- Keep all constants (sizes, positions, movement speeds) in `GameConfig.cs`
- If a private method needs to be called from another class, change that method to be public.
- Avoid the use of Reflection.
- Do not add multiple classes to a single file. Classes should be in their own file.  Structs are an exception to this rule.
- Maintain integer scaling for pixel-perfect rendering
- The width in tiles of the Pit is dynamic, as is the Pit Center X.  This changes for every 10 pit levels.
- The heigh in tiles of the Pit is constant, as is the Pit Center Y
- Ensure the game continues running in idle while the player interacts with other desktop apps
- **Debug Logging Requirements**:
  - Use Nez.Debug for all logs
  - When logging Vectors and Points, log the X & Y components individually.  You can't just write the Vector/Point itself.
  - When logging Rectangles, log the X, Y, Width, and Height individually.  You can't just write the Rectangle itself.
- **Build Requirements**: 
  - Run `getFNA.sh` with automatic "yes" response before building to initialize FNA submodule and dependencies
    - cd /home/runner/work/PitHero/PitHero && echo "y" | ./getFNA.sh
  - Both FNA and Nez must be properly initialized before building.  Check that both subfolders are there.
- **Nez Architecture Compliance**:
  - For random numbers user Nez.Random instead of System.Random
  - Game1 should inherit from `Nez.Core`, not override Draw() or Update() methods
  - Scenes should inherit from `Nez.Scene` and override Initialize() for setup
  - Do not throttle entity update rate unless explicitly asked to.  They should update every frame.  If we want to slow down their speed, use Nez.Time appropriately
  - Use Nez.Time class instead of custom GameTime management.  Use Time.DeltaTime for all timing calculations (movement, animations, etc), so that this properly scales with timeScale.
  - To record total game time played, use Time.TotalTime or Time.UnscaledDeltaTime
  - All components under ECS/Components/, Scenes under ECS/Scenes/
  - If a Service needs to be easily accessed in multiple places, register it with Core.Services.AddService() and then get it from anywhere with Core.Services.GetService<Service>()
  - Any Conditions for the GOAP framework should be added to GoapConstants for strong typing
- There is a virtual logic layer in PitHero.VirtualGame that is intended to simulat the game in a virtual, non-graphical context.  This is important for testing to ensure logic is correct.
- WorldState is a struct.  If we need to pass world state to any method to update the world state, it should be passed by reference.  Passing it by value will only modify a copy of it.  IMPORTANT!!!
- ** AOT compilation compliance**:
  - Avoid garbage generation
  - Only use strings as const. Do not use strings dynamically (e.g. string concatenation, patterns...), this is the most common source of garbage.  The exception to this is in Debug.Log statements.
  - Avoid allocating anything with the new keyword during your game loop, e.g. pre-allocate everything ahead of using them during gameplay.
  - Avoid using LINQ
  - If you are using collections, initialize them with a large enough capacity to avoid their internal data structure being silently recreated.
  - Use for loops instead of foreach loops